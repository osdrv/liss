(import "list" ["push" "range"])

(fn join [arr delim]
    (list:reduce arr (fn [acc chunk]
        (cond (is_empty? acc)
            chunk
            (+ acc (+ delim chunk))
        )
    ) "")
)

(fn match_all [pat s]
    (fn _collect [_s acc mtch ix]
        (cond (>= ix (len mtch))
            acc
            (
                (let _m (get mtch ix))
                (let _subs (builtin:range _s (get _m 0) (get _m 1)))
                (let _acc (list:push acc _subs))
                (_collect _s _acc mtch (+ ix 1))
            )
        )
    )
    (fn _next [acc ix]
        (let _substr (builtin:range s ix (len s)))
        (let _match (builtin:match_ix pat _substr))
        (cond (or (is_null? _match) (is_empty? _match))
            acc
            (
                (let _acc (list:push acc (_collect _substr [] _match 0)))
                (let _nix (get (last _match) 1))
                (_next _acc (+ ix _nix))
            )
        )
    )
    (_next [] 0)
)

(fn reverse [s]
    (fn _next [acc ix]
        (cond (< ix 0)
            acc
            (
                (let _ch (get s ix))
                (let _acc (+ acc _ch))
                (_next _acc (- ix 1))
            )
        )
    )
    (cond (is_null? s)
        null
        (cond (is_empty? s)
            s
            (_next "" (- (len s) 1))
        )
    )
)

; TODO: FIXME: at the moment, delimiter can only be a single rune
(fn split [s delim]
    (fn _next [acc start ix]
        (let _len (len s))
        (cond (>= ix _len)
            (cond (> _len start)
                (list:push acc (list:range s start _len))
                acc
            )
            (
                (cond (= (get s ix) delim)
                    (
                        (let _chunk (list:range s start ix))
                        (let _acc (list:push acc _chunk))
                        (_next _acc (+ ix 1) (+ ix 1))
                    )
                    (_next acc start (+ ix 1))
                )
            )
        )
    )
    (cond (is_null? s)
        null
        (
            (let _res (_next [] 0 0))
            (list:reduce _res (fn [acc chunk] (list:push acc chunk) ) [])
        )
    )
)

(fn atoi [s]
    (cond (is_null? s)
        null
        (cond (is_empty? s)
            (raise! "atoi: empty string")
            (list:reduce s (fn [acc ch]
                (+
                    (* acc 10)
                    (switch ch
                        ["0" 0]
                        ["1" 1]
                        ["2" 2]
                        ["3" 3]
                        ["4" 4]
                        ["5" 5]
                        ["6" 6]
                        ["7" 7]
                        ["8" 8]
                        ["9" 9]
                        [* (raise! (+ "atoi: invalid character '" ch "' in string '" s "'"))]
                    )
                )
            ) 0)
        )
    )
)

(fn has_prefix? [str pref]
    (cond (and (is_string? str) (is_string? pref))
        (cond (< (len str) (len pref))
            false
            (= (builtin:range str 0 (len pref)) pref)
        )
        (raise! "has_prefix?: both arguments must be strings")
    )
)

(fn has_suffix? [str suff]
    (cond (and (is_string? str) (is_string? suff))
        (cond (< (len str) (len suff))
            false
            (= (builtin:range str (- (len str) (len suff)) (len str)) suff)
        )
        (raise! "has_suffix?: both arguments must be strings")
    )
)

(fn trim_prefix [str pref]
    (cond (and (is_string? str) (is_string? pref))
        (cond (has_prefix? str pref)
            (builtin:range str (len pref) (len str))
            str
        )
        (raise! "trim_prefix: both arguments must be strings")
    )
)

(fn trim_suffix [str suff]
    (cond (and (is_string? str) (is_string? suff))
        (cond (has_suffix? str suff)
            (builtin:range str 0 (- (len str) (len suff)))
            str
        )
        (raise! "trim_suffix: both arguments must be strings")
    )
)

(fn trim_left [s chs]
    (cond (or (is_null? s) (is_empty? s) (is_null? chs) (is_empty? chs))
        s
        (
            (let chmp (list:reduce chs (fn [acc ch]
                (put acc ch null)
                acc
            ) (dict)))
            (fn _next [ix]
                (cond (>= ix (len s))

                    ""
                    (cond (has? chmp (get s ix))
                        (_next (+ ix 1))
                        (builtin:range s ix (len s))
                    )
                )
            )
            (_next 0)
        )
    )
)

(fn trim_right [s chs]
    (cond (or (is_null? s) (is_empty? s) (is_null? chs) (is_empty? chs))
        s
        (
            (let chmp (list:reduce chs (fn [acc ch]
                (put acc ch null)
                acc
            ) (dict)))
            (fn _next [ix]
                (cond (< ix 0)
                    ""
                    (cond (has? chmp (get s ix))
                        (_next (- ix 1))
                        (builtin:range s 0 (+ ix 1))
                    )
                )
            )
            (_next (- (len s) 1))
        )
    )
)

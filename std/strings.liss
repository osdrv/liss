(import "list" ["push" "range"])

(fn join [arr delim]
    (list:reduce arr (fn [acc chunk]
        (cond (is_empty? acc)
            chunk
            (+ acc (+ delim chunk))
        )
    ) "")
)

(fn match_all [pat s]
    (fn _collect [_s acc mtch ix]
        (cond (>= ix (len mtch))
            acc
            (
                (let _m (get mtch ix))
                (let _subs (range _s (get _m 0) (get _m 1)))
                (let _acc (list:push acc _subs))
                (_collect _s _acc mtch (+ ix 1))
            )
        )
    )
    (fn _next [acc ix]
        (let _substr (builtin:range s ix (len s)))
        (let _match (builtin:match_ix pat _substr))
        (cond (or (is_null? _match) (is_empty? _match))
            acc
            (
                (let _acc (list:push acc (_collect _substr [] _match 0)))
                (let _nix (get (last _match) 1))
                (_next _acc (+ ix _nix))
            )
        )
    )
    (_next [] 0)
)

(fn reverse [s]
    (fn _next [acc ix]
        (cond (< ix 0)
            acc
            (
                (let _ch (get s ix))
                (let _acc (+ acc _ch))
                (_next _acc (- ix 1))
            )
        )
    )
    (cond (is_null? s)
        null
        (cond (is_empty? s)
            s
            (_next "" (- (len s) 1))
        )
    )
)

; TODO: FIXME: at the moment, delimiter can only be a single rune
(fn split [s delim]
    (fn _next [acc start ix]
        (let _len (len s))
        (cond (>= ix _len)
            (cond (> _len start)
                (list:push acc (list:range s start _len))
                acc
            )
            (
                (cond (= (get s ix) delim)
                    (
                        (let _chunk (list:range s start ix))
                        (let _acc (list:push acc _chunk))
                        (_next _acc (+ ix 1) (+ ix 1))
                    )
                    (_next acc start (+ ix 1))
                )
            )
        )
    )
    (cond (is_null? s)
        null
        (
            (let _res (_next [] 0 0))
            (list:reduce _res (fn [acc chunk] (list:push acc (join chunk "")) ) [])
        )
    )
)

; TODO: implement proper atoi with error handling
; one of the ideas is to allow rune subtraction
(fn atoi [s]
    (cond (is_null? s)
        null
        (cond (is_empty? s)
            (raise! "atoi: empty string")
            (list:reduce s (fn [acc ch]
                (+
                    (* acc 10)
                    (cond (= ch "0")
                        0
                        (cond (= ch "1")
                            1
                            (cond (= ch "2")
                                2
                                (cond (= ch "3")
                                    3
                                    (cond (= ch "4")
                                        4
                                        (cond (= ch "5")
                                            5
                                            (cond (= ch "6")
                                                6
                                                (cond (= ch "7")
                                                    7
                                                    (cond (= ch "8")
                                                        8
                                                        (cond (= ch "9")
                                                            9
                                                            (raise! (+ "atoi: invalid character '" ch "' in string '" s "'"))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            ) 0)
        )
    )
)

(fn has_prefix? [str pref]
    (cond (and (is_string? str) (is_string? pref))
        (cond (< (len str) (len pref))
            false
            (= (list:range str 0 (len pref)) pref)
        )
        (raise! "has_prefix?: both arguments must be strings")
    )
)

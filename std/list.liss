; Standard Liss list/array functions

; `SORT_ASC` is a comparison function for ascending order
(let SORT_ASC (fn [a b] (< a b)))

; `SORT_DESC` is a comparison function for descending order
(let SORT_DESC (fn [a b] (> a b)))

; `push` returns a new array with the value `v` appended to the end
; of array `arr`
(fn push [arr v]
    (cond (is_null? arr)
        null
        (+ arr [v])
    )
)

(fn copy [arr]
    (cond (is_null? arr)
        null
        (+ [] arr)
    )
)

; `reduce` applies function `fun` cumulatively to the items of array `arr`,
; aggregating them into a single value, starting with initial accumulator `acc`
(fn reduce [arr fun acc]
    (cond (is_null? arr)
        null
        (cond (is_empty? arr)
            acc
            (
                (let _acc (fun acc (head arr)))
                (reduce (tail arr) fun _acc)
            )
        )
    )
)

; `map` applies function `fun` to each item of array `arr`,
; returning a new array of the results
(fn map [arr fun]
    (reduce arr (fn [acc x]
        (+ acc [(fun x)])
    ) [])
)

; `filter` returns a new array containing only the items of array `arr`
; for which function `fun` returns true
(fn filter [arr fun]
    (reduce arr (fn [acc x] (
        (+ acc (cond (fun x) [x] []))
    )) [])
)

; `range` returns a sub-array of `arr` from index `start` to `end` (exclusive)
(fn range [arr start end]
    (cond (is_null? arr)
        null
        (cond (>= start (len arr))
            []
            (builtin:range arr start end)
        )
    )
)

; `reverse` returns a new array with the elements of `arr` in reverse order
(fn reverse [arr]
    (fn _next [acc ix]
        (cond (< ix 0)
            acc
            (
                (let _el (get arr ix))
                (let _acc (push acc _el))
                (_next _acc (- ix 1))
            )
        )
    )
    (cond (is_null? arr)
        null
        (_next [] (- (len arr) 1))
    )
)

(fn _find [acc ix arr n break]
    (cond (is_empty? arr)
        acc
        (
            (let _found (= (head arr) n))
            (let _acc
                (cond _found
                    (push acc ix)
                    acc
                )
            )
            (cond (& break _found)
                _acc
                (_find _acc (+ ix 1) (tail arr) n break)
            )
        )
    )
)

; `find` returns the index of the first occurrence of `n` in `arr`,
; or -1 if not found; the search is performed linearly
(fn find [arr n]
    (cond (is_null? arr)
        null
        (
            (let _acc (_find [] 0 arr n true))
            (cond (is_empty? _acc)
                -1
                (head _acc)
            )
        )
    )
)

; `find_bin_fn` performs a binary search on a sorted array `sorted_arr`. It returns the first element
; for which the function `fun` returns true, or -1 if no such element is found
(fn find_bin_fn [sorted_arr fun]
    (fn _next [left right]
        (cond (<= (- right left) 1)
            (cond (fun (get sorted_arr left))
                left
                (cond (fun (get sorted_arr right))
                    right
                    -1
                )
            )
            (
                (let mid (/ (+ left right) 2))
                (cond (fun (get sorted_arr mid))
                    (_next left mid)
                    (_next mid right)
                )
            )
        )
    )
    (cond (is_null? sorted_arr)
        null
        (cond (is_empty? sorted_arr)
            -1
            (_next 0 (- (len sorted_arr) 1))
        )
    )
)

(fn find_bin [sorted_arr n]
    (fn _next [left right]
        (cond (<= (- right left) 1)
            (cond (= n (get sorted_arr left))
                left
                (cond (= n (get sorted_arr right))
                    right
                    -1
                )
            )
            (
                (let mid (/ (+ left right) 2))
                (cond (<= n (get sorted_arr mid))
                    (_next left mid)
                    (_next mid right)
                )
            )
        )
    )
    (cond (is_null? sorted_arr)
        null
        (cond (is_empty? sorted_arr)
            -1
            (_next 0 (- (len sorted_arr) 1))
        )
    )
)

; `contains?` returns true if `n` is found in `arr`, false otherwise
(fn contains? [arr n]
    (cond (is_null? arr)
        false
        (cond (>= (find arr n) 0)
            true
            false
        )
    )
)

; `find_all` returns an array of all indices where `n` occurs in `arr`
; the search is performed linearly
(fn find_all [arr n]
    (cond (is_null? arr)
        null
        (
            (let _res (_find [] 0 arr n false))
            _res
        )
    )
)

;@mutator
(fn quicksort_fn_mut [arr fun]
    (fn _partition [low high]
        (let _pivot (get arr high))
        (let _i (- low 1))
        (fn _next [j i]
            (cond (> j (- high 1))
                i
                (
                    (cond (fun (get arr j) _pivot)
                        (
                            (let _new_i (+ i 1))
                            (let _temp (get arr _new_i))
                            (put arr _new_i (get arr j))
                            (put arr j _temp)
                            (_next (+ j 1) _new_i)
                        )
                        (_next (+ j 1) i)
                    )
                )
            )
        )
        (let i1 (_next low _i))
        (let _temp (get arr (+ i1 1)))
        (put arr (+ i1 1) (get arr high))
        (put arr high _temp)
        (+ i1 1)
    )

    (fn _qs [low high]
        (cond (< low high)
            (
                (let pi (_partition low high))
                (_qs low (- pi 1))
                (_qs (+ pi 1) high)
            )
        )
    )

    (cond (not (is_null? arr))
        (cond (>= (len arr) 2)
            (_qs 0 (- (len arr) 1))
        )
    )
    arr
)

; `quicksort` sorts the array `arr` using the quicksort algorithm
(fn quicksort [arr]
    (cond (or (is_empty? arr) (< (len arr) 2))
        arr
        (
            (let _pivot (head arr))
            (let _parts (reduce
                (tail arr)
                (fn [acc x]
                    (
                        (let _lt (get acc 0))
                        (let _gt (get acc 1))
                        (cond (< x _pivot)
                            [
                                (push _lt x)
                                _gt
                            ]
                            [
                                _lt
                                (push _gt x)
                            ]
                        )
                    )
                )
                [[] []]
            ))
            (+
                (quicksort (get _parts 0))
                [_pivot]
                (quicksort (get _parts 1))
            )
        )
    )

)

; `mergesort` sorts the array `arr` using the mergesort algorithm
(fn mergesort_fn [arr fun]
    (fn _merge2 [acc a aix b bix]
        (cond (>= aix (len a))
            (+ acc (range b bix (len b)))
            (cond (>= bix (len b))
                (+ acc (range a aix (len a)))
                (cond (fun (get a aix) (get b bix))
                    (_merge2 (+ acc [(get a aix)]) a (+ aix 1) b bix)
                    (_merge2 (+ acc [(get b bix)]) a aix b (+ bix 1))
                )
            )
        )
    )
    (fn _mergesort [arr]
        (cond (< (len arr) 2)
            arr
            (
                (cond (= (len arr) 2)
                    (
                        (let a (get arr 0))
                        (let b (get arr 1))
                        (cond (fun a b)
                            [a b]
                            [b a]
                        )
                    )
                    (
                        (let _mid (/ (len arr) 2))
                        (let _a (range arr 0 _mid))
                        (let _b (range arr _mid (len arr)))
                        (_merge2 [] (_mergesort _a) 0 (_mergesort _b) 0)
                    )
                )
            )
        )
    )

    (cond (or (is_null? arr) (< (len arr) 2))
        arr
        (_mergesort arr)
    )
)

; `sort` sorts the array `arr` using `SORT_ASC` ordering
(fn sort [arr]
    (cond (is_null? arr)
        null
        (
            (let _len (len arr))
            (cond (<= _len 1)
                arr
                (mergesort_fn arr SORT_ASC)
            )
        )
    )
)

; `sort_fn` sorts the array `arr` using the comparison function `fun`
(fn sort_fn [arr fun]
    (cond (is_null? arr)
        null
        (
            (cond (<= (len arr) 1)
                arr
                (mergesort_fn arr fun)
            )
        )
    )
)

(fn seq [a b]
    (fn _next [acc ix]
        (cond (> ix b)
            acc
            (
                (let _acc (push acc ix))
                (_next _acc (+ ix 1))
            )
        )
    )
    (cond (> a b)
        []
        (_next [] a)
    )
)

(fn push [arr v]
    (+ arr [v])
)

(fn reduce [arr fun acc]
    (cond (or (is_null? arr) (is_empty? arr))
        acc
        (
            (let _acc (fun acc (head arr)))
            (reduce (tail arr) fun _acc)
        )
    )
)

(fn map [arr fun]
    (reduce arr (fn [acc x]
        (+ acc [(fun x)])
    ) [])
)

(fn filter [arr fun]
    (reduce arr (fn [acc x] (
        (+ acc (cond (fun x) [x] []))
    )) [])
)

(fn _range [acc ix arr start end]
    (cond (or (< ix start) (>= ix end) (>= ix (len arr)))
        acc
        (
            (let _acc (push acc (get arr ix)))
            (_range _acc (+ ix 1) arr start end)
        )
    )
)

(fn range [arr start end]
    (cond (is_null? arr)
        null
        (cond (>= start (len arr))
            []
            (_range [] start arr start end)
        )
    )
)

(fn _find [acc ix arr n break]
    (cond (is_empty? arr)
        acc
        (
            (let _found (= (head arr) n))
            (let _acc
                (cond _found
                    (push acc ix)
                    acc
                )
            )
            (cond (& break _found)
                _acc
                (_find _acc (+ ix 1) (tail arr) n break)
            )
        )
    )
)

(fn find [arr n]
    (let _acc (_find [] 0 arr n true))
    (cond (is_empty? _acc)
        -1
        (head _acc)
    )
)

(fn find_all [arr n]
    (let _res (_find [] 0 arr n false))
    _res
)

(fn _min2 [a b] (cond (< a b) a b))

(fn _max2 [a b] (cond (> a b) a b))

(fn _quicksort [arr]
    (cond (or (is_empty? arr) (< (len arr) 2))
        arr
        (
            (let _pivot (head arr))
            (let _parts (reduce
                (tail arr)
                (fn [acc x]
                    (
                        (let _lt (get acc 0))
                        (let _gt (get acc 1))
                        (cond (< x _pivot)
                            [
                                (push _lt x)
                                _gt
                            ]
                            [
                                _lt
                                (push _gt x)
                            ]
                        )
                    )
                )
                [[] []]
            ))
            (+
                (_quicksort (get _parts 0))
                [_pivot]
                (_quicksort (get _parts 1))
            )
        )
    )

)

(fn mergesort [arr]
    (fn _merge2 [acc a aix b bix]
        (cond (>= aix (len a))
            (+ acc (range b bix (len b)))
            (cond (>= bix (len b))
                (+ acc (range a aix (len a)))
                (cond (< (get a aix) (get b bix))
                    (_merge2 (+ acc [(get a aix)]) a (+ aix 1) b bix)
                    (_merge2 (+ acc [(get b bix)]) a aix b (+ bix 1))
                )
            )
        )
    )
    (fn _mergesort [arr]
        (cond (< (len arr) 2)
            arr
            (
                (cond (= (len arr) 2)
                    [
                        (_min2 (get arr 0) (get arr 1))
                        (_max2 (get arr 0) (get arr 1))
                    ]
                    (
                        (let _mid (/ (len arr) 2))
                        (let _a (range arr 0 _mid))
                        (let _b (range arr _mid (len arr)))
                        (_merge2 [] (_mergesort _a) 0 (_mergesort _b) 0)
                    )
                )
            )
        )
    )

    (cond (or (is_null? arr) (< (len arr) 2))
        arr
        (_mergesort arr)
    )
)


(fn sort [arr]
    (cond (is_null? arr)
        null
        (
            (let _len (len arr))
            (cond (<= _len 1)
                arr
                (_quicksort arr)
            )
        )
    )
)

(fn _benchmark [fun]
    (let _start (time_ms))
    (let _res (fun))
    (let _end (time_ms))
    (print "Time taken (msec): ")
    (println (- _end _start) "\n")
    _res
)

(fn _mk_rand_vec [size]
    (fn _next [ix acc]
        (cond (>= ix size)
            acc
            (
                (let _acc (+ acc [(randn 100)]))
                (_next (+ ix 1) _acc)
            )
        )
    )
    (_next 0 [])
)

(fn test []
    (
        (let vec (_mk_rand_vec 1000))
        (print "list: ")
        (println vec "\n")

        (_benchmark (fn [] (
            (print "find: ")
            (println (find vec 7))
            (print "find_all: ")
            (println (find_all vec 7))
        )))

        (_benchmark (fn [] (
            (print "range 0..2: ")
            (println (range vec 0 2))
            (print "range 2..10: ")
            (println (range vec 2 10))
        )))

        (_benchmark (fn [] (
            (print "merge-sorted: ")
            (println (mergesort vec))
        )))

        (_benchmark (fn [] (
            (print "quick-sorted: ")
            (println (_quicksort vec))
        )))

        (_benchmark (fn [] (
            (print "filtered < 10: ")
            (println (filter vec (fn [x] (< x 10))))
        )))

        (_benchmark (fn [] (
            (print "reduced < 10: ")
            (println (reduce vec (fn [acc x] (
                (+ acc (cond (< x 10) [x] []))
            )) []))
        )))

        (_benchmark (fn [] (
            (print "mapped * 2: ")
            (println (map vec (fn [x] (* x 2))))
        )))
    )
)

(test)

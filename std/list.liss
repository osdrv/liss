(fn push [arr v]
    (cond (is_null? arr)
        null
        (+ arr [v])
    )
)

(fn reduce [arr fun acc]
    (cond (is_null? arr)
        null
        (cond (is_empty? arr)
            acc
            (
                (let _acc (fun acc (head arr)))
                (reduce (tail arr) fun _acc)
            )
        )
    )
)

(fn map [arr fun]
    (reduce arr (fn [acc x]
        (+ acc [(fun x)])
    ) [])
)

(fn filter [arr fun]
    (reduce arr (fn [acc x] (
        (+ acc (cond (fun x) [x] []))
    )) [])
)

(fn range [arr start end]
    (cond (is_null? arr)
        null
        (cond (>= start (len arr))
            []
            (builtin:range arr start end)
        )
    )
)

(fn reverse [arr]
    (fn _next [acc ix]
        (cond (< ix 0)
            acc
            (
                (let _el (get arr ix))
                (let _acc (push acc _el))
                (_next _acc (- ix 1))
            )
        )
    )
    (cond (is_null? arr)
        null
        (_next [] (- (len arr) 1))
    )
)

(fn _find [acc ix arr n break]
    (cond (is_empty? arr)
        acc
        (
            (let _found (= (head arr) n))
            (let _acc
                (cond _found
                    (push acc ix)
                    acc
                )
            )
            (cond (& break _found)
                _acc
                (_find _acc (+ ix 1) (tail arr) n break)
            )
        )
    )
)

(fn find [arr n]
    (let _acc (_find [] 0 arr n true))
    (cond (is_empty? _acc)
        -1
        (head _acc)
    )
)

(fn contains? [arr n]
    (cond (>= (find arr n) 0)
        true
        false
    )
)

(fn find_all [arr n]
    (let _res (_find [] 0 arr n false))
    _res
)

(fn quicksort [arr]
    (cond (or (is_empty? arr) (< (len arr) 2))
        arr
        (
            (let _pivot (head arr))
            (let _parts (reduce
                (tail arr)
                (fn [acc x]
                    (
                        (let _lt (get acc 0))
                        (let _gt (get acc 1))
                        (cond (< x _pivot)
                            [
                                (push _lt x)
                                _gt
                            ]
                            [
                                _lt
                                (push _gt x)
                            ]
                        )
                    )
                )
                [[] []]
            ))
            (+
                (quicksort (get _parts 0))
                [_pivot]
                (quicksort (get _parts 1))
            )
        )
    )

)

(fn mergesort [arr]
    (fn _min2 [a b] (cond (< a b) a b))
    (fn _max2 [a b] (cond (> a b) a b))
    (fn _merge2 [acc a aix b bix]
        (cond (>= aix (len a))
            (+ acc (range b bix (len b)))
            (cond (>= bix (len b))
                (+ acc (range a aix (len a)))
                (cond (< (get a aix) (get b bix))
                    (_merge2 (+ acc [(get a aix)]) a (+ aix 1) b bix)
                    (_merge2 (+ acc [(get b bix)]) a aix b (+ bix 1))
                )
            )
        )
    )
    (fn _mergesort [arr]
        (cond (< (len arr) 2)
            arr
            (
                (cond (= (len arr) 2)
                    [
                        (_min2 (get arr 0) (get arr 1))
                        (_max2 (get arr 0) (get arr 1))
                    ]
                    (
                        (let _mid (/ (len arr) 2))
                        (let _a (range arr 0 _mid))
                        (let _b (range arr _mid (len arr)))
                        (_merge2 [] (_mergesort _a) 0 (_mergesort _b) 0)
                    )
                )
            )
        )
    )

    (cond (or (is_null? arr) (< (len arr) 2))
        arr
        (_mergesort arr)
    )
)


(fn sort [arr]
    (cond (is_null? arr)
        null
        (
            (let _len (len arr))
            (cond (<= _len 1)
                arr
                (quicksort arr)
            )
        )
    )
)

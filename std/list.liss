(fn list:head [arr]
    (cond (or (is_null? arr) (is_empty? arr))
        null
        (get arr 0)
    )
)

(fn list:push [arr v]
    (+ arr [v])
)

(fn list:reduce [arr fun acc]
    (cond (or (is_null? arr) (is_empty? arr))
        acc
        (
            (let _acc (fun acc (list:head arr)))
            (list:reduce (tail arr) fun _acc)
        )
    )
)

(fn list:map [arr fun]
    (list:reduce arr (fn [acc x]
        (+ acc [(fun x)])
    ) [])
)

(fn list:filter [arr fun]
    (list:reduce arr (fn [acc x] (
        (+ acc (cond (fun x) [x] []))
    )) [])
)

(fn _range [acc ix arr start end]
    (cond (or (< ix start) (>= ix end) (>= ix (len arr)))
        acc
        (
            (let _acc (list:push acc (get arr ix)))
            (_range _acc (+ ix 1) arr start end)
        )
    )
)

(fn list:range [arr start end]
    (cond (is_null? arr)
        null
        (cond (>= start (len arr))
            []
            (_range [] start arr start end)
        )
    )
)

(fn _find [acc ix arr n break]
    (cond (is_empty? arr)
        acc
        (
            (let _found (= (list:head arr) n))
            (let _acc
                (cond _found
                    (list:push acc ix)
                    acc
                )
            )
            (cond (& break _found)
                _acc
                (_find _acc (+ ix 1) (tail arr) n break)
            )
        )
    )
)

(fn list:find [arr n]
    (let _acc (_find [] 0 arr n true))
    (cond (is_empty? _acc)
        -1
        (list:head _acc)
    )
)

(fn list:find_all [arr n]
    (let _res (_find [] 0 arr n false))
    _res
)

(fn _min2 [a b] (cond (< a b) a b))

(fn _max2 [a b] (cond (> a b) a b))

(fn _quicksort [arr]
    (cond (or (is_empty? arr) (< (len arr) 2))
        arr
        (
            (let _pivot (head arr))
            (let _parts (list:reduce
                (tail arr)
                (fn [acc x]
                    (
                        (let _lt (get acc 0))
                        (let _gt (get acc 1))
                        (cond (< x _pivot)
                            [
                                (list:push _lt x)
                                _gt
                            ]
                            [
                                _lt
                                (list:push _gt x)
                            ]
                        )
                    )
                )
                [[] []]
            ))
            (+
                (_quicksort (get _parts 0))
                [_pivot]
                (_quicksort (get _parts 1))
            )
        )
    )

)

(fn _merge [a aix alen b bix blen]
    (cond
        (and (>= aix alen) (>= bix blen))
        []
        (cond (>= aix alen)
            (list:range b bix blen)
            (cond (>= bix blen)
                (list:range a aix alen)
                (cond (< (get a aix) (get b bix))
                    (+ [(get a aix)] (_merge a (+ aix 1) alen b bix blen))
                    (+ [(get b bix)] (_merge a aix alen b (+ bix 1) blen))
                )
            )
        )
    )
)

(fn _mergesort [arr]
    (let _len (len arr))
    (cond (<= _len 1)
        arr
        (cond (= _len 2)
            [
                (_min2 (get arr 0) (get arr 1))
                (_max2 (get arr 0) (get arr 1))
            ]
            (
                (let _mid (/ _len 2))
                (let _a (list:range arr 0 _mid))
                (let _b (list:range arr _mid _len))
                (_merge
                    (_mergesort _a)
                    0
                    (len _a)
                    (_mergesort _b)
                    0
                    (len _b)
                )
            )
        )
    )
)


(fn list:sort [arr]
    (cond (is_null? arr)
        null
        (
            (let _len (len arr))
            (cond (<= _len 1)
                arr
                (_mergesort arr)
            )
        )
    )
)

(fn _benchmark [fun]
    (let _start (time_ms))
    (let _res (fun))
    (let _end (time_ms))
    (print "Time taken (msec): ")
    (print (- _end _start))
    (print "\n\n")
    _res
)

(fn _mk_rand_vec [size]
    (fn _next [ix] (
        (cond (>= ix size)
            []
            (+ [(rand:intn 100)] (_next (+ ix 1)))
        )
    ))
    (_next 0)
)

(fn test []
    (
        (let vec (_mk_rand_vec 250))
        (print "list: ")
        (print vec)
        (print "\n\n")

        (_benchmark (fn [] (
            (print "list:find: ")
            (print (list:find vec 7))
            (print "\n")
            (print "list:find_all: ")
            (print (list:find_all vec 7))
            (print "\n")
        )))

        (_benchmark (fn [] (
            (print "range 0..2: ")
            (print (list:range vec 0 2))
            (print "\n")
            (print "range 2..10: ")
            (print (list:range vec 2 10))
            (print "\n")
        )))

        (_benchmark (fn [] (
            (print "merge-sorted: ")
            (print (_mergesort vec))
            (print "\n")
        )))

        (_benchmark (fn [] (
            (print "quick-sorted: ")
            (print (_quicksort vec))
            (print "\n")
        )))

        (_benchmark (fn [] (
            (print "filtered < 10: ")
            (print (list:filter vec (fn [x] (< x 10))))
            (print "\n")
        )))

        (_benchmark (fn [] (
            (print "reduced < 10: ")
            (print (list:reduce vec (fn [acc x] (
                (+ acc (cond (< x 10) [x] []))
            )) []))
            (print "\n")
        )))

        (_benchmark (fn [] (
            (print "mapped * 2: ")
            (print (list:map vec (fn [x] (* x 2))))
            (print "\n")
        )))
    )
)

(test)

(fn list:reduce [arr fun acc]
    (cond (or (is_null? arr) (is_empty? arr))
        acc
        (
            (let _acc (fun acc (head arr)))
            (list:reduce (tail arr) fun _acc)
        )
    )
)

(fn _mk_rand_vec [size]
    (fn _next [ix acc]
        (cond (>= ix size)
            acc
            (
                (let _acc (+ acc [(rand:intn 100)]))
                (_next (+ ix 1) _acc)
            )
        )
    )
    (_next 0 [])
)

"This example demonstrates how the tail recursion optimization works in Liss."
"The default recursion limit is set to 1024, so creating a list with"
"more than 1024 elements without tail recursion optimization would normally"
"lead to a stack overflow. Here it works just fine."
(let _big_vec (_mk_rand_vec 10000))
(print _big_vec)
(print "\n")
